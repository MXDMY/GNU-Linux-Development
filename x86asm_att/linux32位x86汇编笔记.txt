# 无非地址、数据、指令、寄存器，标签（也称符号）即地址（会被汇编器解释为紧随其后的数据或代码的地址），示例中以 label 作为某一代码、数据开始的标签

# 对于运行在 x86 架构的 32位 Linux 系统
# %eax 放系统调用号，%ebx 放退出状态码，int $0x80 触发软中断

# 汇编程序能直接识别两个常数加减，如 'A' - 'a' 以及 $4 + label，汇编后直接为结果常数

# 声明总结
.section .data          # 表明接下来为数据段
.section .bss           # 表明接下来为 未初始化 数据段，可用做缓冲区
.lcomm label , 500      # 创建 500 字节的缓冲区，地址起始用 label 指代
.long 3 , 4             # 随后数据 3 , 4 均为 4 字节长度数据
.section .text          # 接下来为文本段（代码段）
.global label           # 告知汇编器汇编后不应废弃标签 label，链接器还需要该标签
.type label , @function # 告诉链接器符号 label 作为函数处理，用于多文件
.equ SYS_EXIT , 1       # 为数字分配名称

.include "head.s"       # 类似于 C语言 的 #include，包含后无需再单独汇编被包含后的 .s 文件
                        # 若只在 a.s 中使用 b.s 的函数，则无需此声明，正常汇编链接即可
                        # 链接器能将 导出函数 与 .global 指令相结合，如".global label\n.type label , @function"

.rept 30                # 将 .rept 与 .endr 之间的段重复指定次数，这里是将 0（占一字节） 重复 30 次
.byte 0
.endr

.ascii "hello world\0"  # 字符串声明，"\0" 建议显式写出，不同于 Ｃ语言，汇编器不会隐式添加

# 指令例子总结，字长以 l 为标准，即 4 字节
movl %eax , %ebx        # %eax 值移入 %ebx
incl %eax               # 加一
decl %eax               # 减一
imull %eax , %ebx       # 整数乘法，结果保存到 %ebx
cmpl %eax , %ebx        # 比较，结果保存到 %eflags
je|jl|jle|jg|jge label  # 条件跳转，依据 %eflags 值进行跳转
jmp label               # 无条件跳转
subl $4 , %eax          # 减法，%eax 值减 4
addl $4 , %eax          # 加法，值加 4
pushl %eax              # 值入栈，并将 %esp 中数据减 4
popl %eax               # 出栈，弹出数据保存到 %eax，并将 %esp 中数据加 4
call label              # 将返回地址（下一条指令地址）入栈，并修改指令指针 %eip 指向 label 起始处
ret                     # 弹出栈顶值，并将 %eip 设置为该弹出值

# 比较第二个数与第一个数，结果放在 %eflags 寄存器，可配合 je, jl , jle , jg , jge 条件跳转指令使用
cmpl %eax , %ebx
je label # 条件跳转，相等则跳转，不同于指令 jmp 可无条件跳转

# 内存通用寻址、索引寻址，[地址|偏移]([基址寄存器] , [索引寄存器] , [比例系数])
# 结果地址 = 地址|偏移 + %[基址|偏移寄存器] + %[索引寄存器] * [比例系数]，输入两必为常量，两必为寄存器，缺省默认为0
label(, %edi , 4)
# 直接寻址
movl label , %eax # 将地址 label 处的 4 字节数据移入 %eax
movb 3 , %eax     # 将地址 3 处的 1 字节数据移入 %eax
# 间接寻址
movl (%eax) , %ebx # 将 %eax 保存的数据作为地址，并将该地址的 4 字节数据移入 %ebx
# 基址寻址
movl 3(%eax) , %ebx  # 将 %eax 保存的数据作为地址，并将该地址向 后 偏移 3 字节的 4 字节数据移入 %ebx
movl -3(%eax) , %ebx # 将 %eax 保存的数据作为地址，并将该地址向 前 偏移 3 字节的 4 字节数据移入 %ebx
# 立即寻址
movl $label , %eax # 将 label 作为数据移入
movl $3 , %eax     # 将 3 作为数据移入
# 寄存器寻址
movl %eax , %ebx

# 函数调用，需要明确的问题如下：
# 1、当参数个数多于一个时, 按照什么顺序把参数压入堆栈
# 2、函数调用后, 由谁来把堆栈恢复原装
# 3、函数的返回值放在什么地方
# 在高级语言中, 通过函数调用规范(Calling Conventions)来说明上述问题. 常见的调用规范有：stdcall、cdecl、fastcall、thiscall、naked call，例子如下：
# int function(int a , int b)         //不加修饰默认就是C调用约定
# int __cdecl function(int a , int b) //明确指定C调用约定
# AT&T汇编函数，使用 C 调用约定
# 栈寄存器 %esp 内部数据为指向栈顶的地址，栈由高地址向低地址扩张，先进后出
pushl %eax # 将 %eax 中数据 入 栈，并将 %esp 中数据减 4
popl %eax  # 将 %eax 中数据 出 栈，并将 %esp 中数据加 4
# 指令 call 将返回地址（下一条指令地址）入栈，并修改指令指针 %eip 指向所调用的函数地址起始处
# 由于函数使用过程中还需压入内部变量，导致 %esp 进一步变化，为防止丢失参数、返回地址的位置，可在返回地址压入后，将 %esp 数据保存下来
pushl %ebp       # 由于将 %ebp 作为保存点，原有内容会被 %esp 中数据覆盖，因此将 %ebp 数据入栈，以便函数结束后恢复，若函数还会使用其它寄存器，同样如此，这些寄存器原有内容可能别的代码指令会需要
movl %esp , %ebp # 保存在 %ebp 中，可用其它寄存器，但 x86 中，%ebp 快
# 再为函数内部变量预留空间
subl $8 , %esp # %esp 减 8，预留 8 字节空间，符号 $ 不能掉，否则就成了减去地址 8 起始处的 4 字节数据（4字节数据换算成十进制搞不好直接起飞）
# 函数使用完毕后：
# 返回值保存在 %eax，这里值得注意的是，调用函数之前是否保留下 %eax 的值，保存点可选择在栈中，参数入栈前
# 恢复栈
# 控制权交还，通过指令 ret，弹出栈顶值，并将 %eip 设置为该弹出值
movl %ebp , %esp
popl %ebp # 这两步使得 %esp 回到了返回地址所在位置，越过的栈数据相当于抛弃，以后可能会被新函数覆盖
ret       # 到这步，现在栈中只剩下该函数的参数
# 最后，让调用函数的代码弹出函数参数，可用指令 addl 直接越过参数
# 如果在调用函数前，有保留寄存器数据，如 %eax，现在便可以恢复了

# Linux 程序内存布局
# 程序被加载到内存后，每个段中代码和数据将被组合起来，即使它们在源代码中是分离的，如下
#
# High Addresses -> .----------------------. 0xbfffffff
#                   |      Environment     |
#                   |----------------------|                |----------------------|
#                   |        STACK         | -------------> |       ...(argn)      |
# base pointer ->   | - - - - - - - - - - -|                |         arg2         |
#                   |          |           |                |         arg1         |
#                   |          v           |                |     program name     |
#                   :                      :                |     number of arg    |
#                   .        Empty         .                |         ...          |
#                   :                      :
#                   |          ^           |
#                   |          |           |
# brk point ->      | - - - - - - - - - - -|
#                   |         HEAP         |
#                   |----------------------|
#                   |         BSS          |
#                   |----------------------|   
#                   |         Data         |
#                   |----------------------|
#                   |         Text         |
# Low Addresses ->  '----------------------' 0x08048000

### 问题与答案 ###
# ？？？Linux 程序开始时，所有指向命令行参数的 指针 都存放于栈中，参数数目存放于 8(%esp)，程序名存放于 12(%esp)，参数指针存放于 16(%esp) 及其后的位置？？？
# 答：有些系统下 (%esp) 才是参数数目，程序名存放于 4(%esp)，参数指针存放于 8(%esp) 及其后的位置

# ？？？没有 '\0' 这种东西，只有在 .ascii 声明的字符串才能出现 "***\0"，或者单独的 '\0' 不解释为 0，只有在字符串中才是 0？？？
# 答：单独的 '\0' 解释为 常数48，即 '0'，只有在 .ascii 声明的字符串才被解释为 常数0
# 补充：字符串中的 "\0" 和 C语言 的情况大不一样，比如 "\06" 会被解释为其它情况，而不是简单的字符 "6" 然后前面是一个 字符串终止符，故慎用

# ？？？函数的传入参数的类型占用若不足 4 字节，栈上仍以 4 字节空间分配，x64 则是 8 字节？？？
# 答：

# ？？？Linux 系统调用 brk 的参数与返回值的实际情况？？？
# 答：